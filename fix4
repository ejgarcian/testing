/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package edd;

/**
 * Esta clase define un objeto de tipo lista. Contiene un contador de su
 * cantidad de elementos, una lista donde se almacenan los objetos siguienres y
 * un elemento de tipo ElementoLista.
 *
 * @version 27/10/2024
 * @author Michelle García
 */
public class Lista {

    private int count = 0;
    private Lista next;
    private ElementoLista value;

    /**
     * Procedimiento para agregar un objeto en la lista
     *
     * @param value1 Proceso
     */
    public void add(Object value1) {
        if (value1 != null) {
            ElementoLista newValue = new ElementoLista();
            newValue.setValue(value1);
            newValue.setIndex(count);

            if (this.value == null) {
                this.value = newValue;
            } else {
                Lista actual = this;
                while (actual.next != null) {
                    actual = actual.next;
                }
                actual.next = new Lista();
                actual.next.value = newValue;
            }

            count++;
        }
    }


    /**
     * Función para obtener un elemento según su índice dentro de la lista
     *
     * @param index Índice del elemento a retornar
     * @return Elemento encontrado según su índice (o null si fuera de rango)
     */
    public Object get(int index) {
        if (index < 0) return null;
        Lista current = this;
        int i = 0;
        // Walk nodes until we find the index or run out of nodes
        while (current != null && current.value != null) {
            if (i == index) {
                return current.value.getValue();
            }
            current = current.next;
            i++;
        }
        // index out of range
        return null;
    }

    /**
     * Procedimiento para eliminar un elemento de la lista según su índice
     *
     * @param index Indice del elemento a eliminar
     */
    public void remove(int index) {
        if (index >= 0 && index < count()) {
            if (index == 0) {

                if (this.next == null) {
                    this.value = null;
                } else {
                    this.value = this.next.value;
                    this.next = this.next.next;
                }
            } else {
                Lista actual = this;
                for (int i = 0; i < index - 1; i++) {
                    actual = actual.next;
                }


                actual.next = actual.next.next;
            }


            Lista temp = this;
            int indiceActual = 0;
            while (temp != null) {
                if (temp.value != null) {
                    temp.value.setIndex(indiceActual);
                    indiceActual++;
                }
                temp = temp.next;
            }

            count--;
        }
    }

    /**
     * Función para contar los elementos dentro de la lista
     *
     * @return Cantidad de elementos de la lista
     */
    public int count() {
        // Iterative, defensive count that walks nodes with non-null ElementoLista.value
        int cnt = 0;
        Lista current = this;
        while (current != null && current.value != null) {
            cnt++;
            current = current.next;
        }
        // Keep the internal count field in sync (defensive)
        this.count = cnt;
        return cnt;
    }

    /**
     * Procedimiento para agregar los elementos de una lista externa a la lista
     * actual
     *
     * @param h Lista externa
     */
    public void addRange(Lista h) {

        if (h.count() > 0) {
            Lista actual = h;
            while (actual != null && actual.value != null) {

                if (!this.contains(actual.value.getValue())) {
                    this.add(actual.value.getValue());
                }
                actual = actual.next;
            }
        }
    }

    
    
    public String printListProcess() {
        String txt = "";
        
        for (int i = 0; i < count(); i++) {
            Object o = get(i);
            if (o instanceof Proceso) {
                txt = txt + ((Proceso)o).getName() + "\n";
            }
        }
        return txt;
    }
    
    
    
    /**
     * Función para verificar si un objeto se encuentra dentro de la lista.
     *
     * @param value Objeto a encontrar
     * @return Si el objeto se encuentra adentro, true. En caso contrario,
     * false.
     */
    public boolean contains(Object value) {
        if (value == null) return false;
        Lista current = this;
        while (current != null && current.value != null) {
            Object v = current.value.getValue();
            if (v == value || (v != null && v.equals(value))) return true;
            current = current.next;
        }
        return false;
    }

 /**
    /*
    /**
     
    Función para obtener el índice de un elemento dentro de la lista.*
    @param value Objeto a encontrar.
    @return Posición correspondiente al elemento en la lista.*/
    public int indexOf(Object value) {
        if (value == null) return -1;
        Lista current = this;
        while (current != null && current.value != null) {
            Object aux = current.value.getValue();
            if ((value instanceof PCB) && (aux instanceof PCB) && ((PCB)aux).getId() == ((PCB)value).getId()) {
                return current.value.getIndex();
            } else if ((value instanceof Device) && (aux instanceof Device) && ((Device)aux).getId() == ((Device)value).getId()){
                return current.value.getIndex();
            } else if ((value instanceof Proceso) && (aux instanceof Proceso) && ((Proceso)aux).getPcb().getId() == ((Proceso)value).getPcb().getId()) {
                return current.value.getIndex();
            } else if (aux == value || (aux != null && aux.equals(value))) {
                return current.value.getIndex();
            }
            current = current.next;
        }
        return -1;
    }
    
    private Lista getNodeAt(int index) {
        if (index < 0) return null;
        Lista current = this;
        int i = 0;
        while (current != null && current.value != null && i < index) {
            current = current.next;
            i++;
        }
        return current;
    }

    /**
     * Intercambia los valores almacenados en los nodos de índice i y j.
     * Actualiza los índices de ElementoLista para mantener consistencia.
     *
     * @param i índice del primer elemento
     * @param j índice del segundo elemento
     */
    public void swap(int i, int j) {
        if (i == j) return; // nada que hacer
        if (i < 0 || j < 0) return;
        if (i >= count() || j >= count()) return;

        // asegurar que i < j para simplificar
        if (i > j) {
            int tmp = i;
            i = j;
            j = tmp;
        }
        

        Lista nodeI = getNodeAt(i);
        Lista nodeJ = getNodeAt(j);

        if (nodeI == null || nodeJ == null) return;

        // intercambio simple de los valores
        ElementoLista tempValue = nodeI.value;
        nodeI.value = nodeJ.value;
        nodeJ.value = tempValue;

        // recomputar índices (mantener igual comportamiento que remove)
        recomputeIndices();
    }

    /**
     * Recalcula los índices (ElementoLista.index) a partir del inicio de la lista.
     * Llamar esto después de operaciones que cambien el orden o contenido.
     */
    private void recomputeIndices() {
        Lista temp = this;
        int idx = 0;
        while (temp != null) {
            if (temp.value != null) {
                temp.value.setIndex(idx);
                idx++;
            }
            temp = temp.next;
        }
        // update count to match number of non-null values (defensive)
        this.count = idx;
    }
    
}```

```java name=Testing/src/edd/Scheduler.java url=https://github.com/ejgarcian/testing/blob/main/Testing/src/edd/Scheduler.java
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package edd;

/**
 *
 * @author miche_ysmoa6e
 */
public class Scheduler {
    
    // Tomando que 1 ciclo de ejecución del CPU son 0.00001ms
    
    private Lista processList; //Lista en la cual se guardan todos los procesos a ejecutar.
    private int memoryAvaiable;
    private Lista deviceTable = new Lista();
    private int remainingSpace = memoryAvaiable;
                                     //Se agregan desde la interfaz

    public Scheduler(Lista processList, int memorySpace, Lista deviceTable) {
        this.processList = processList;
        this.memoryAvaiable = memorySpace;
        this.deviceTable = deviceTable;
        this.remainingSpace = memoryAvaiable;
    }
    
    
    // quantum medido en ms
    public void RoundRobin (int setQuantum, Cola readyQueue, Dispatcher dispatcher, Cola blockedQueue, Lista terminatedProcessList){
        int quantum = setQuantum;
         
        if (readyQueue.getCount() > 0){

            var processToActivate = readyQueue.dequeue();
            PCB pcbOfActiveProcess = ((PCB)processToActivate);
            
            // verificar si el proceso ya está activado y si no lo está, activarlo   
            if (!"running".equals(pcbOfActiveProcess.getStatus())){
                dispatcher.activate(pcbOfActiveProcess, getProcessList()); // ready ---> running
            }
            
            Proceso toRun = dispatcher.getActiveProcess(getProcessList());
            if (toRun == null) return;
            
            while("running".equals(toRun.getPcb().getStatus())) {
                // honor interruption from the scheduler thread (UI changed planification)
                if (Thread.currentThread().isInterrupted()) return;

                System.out.println("is running");
                if (toRun.getTimeSpent() >= quantum || toRun.getProcessingTime() <= toRun.getTotalTimeSpent()){
                    dispatcher.deactivate(toRun);   // running --> ready
                    // break early because we preempted the process
                    break;
                }
            
                if ("I/O Bound".equals(toRun.getBound()) && toRun.getPcb().getPc()-1 == toRun.getInterruptAt()){
                    toRun.getPcb().setStatus("blocked");
                    blockedQueue.enqueue(toRun.getPcb());
                    try {
                        Thread.sleep((long)toRun.getIoCicles()*1000);
                        accessDevice(toRun, dispatcher, blockedQueue);
                    } 
                    catch(InterruptedException e) {
                         // honor interruption — propagate by setting the interrupted flag and return
                         Thread.currentThread().interrupt();
                         return;
                    }                
                }                
                try {
                    Thread.sleep(1000);
                } 
                catch(InterruptedException e) {
                     // honor interruption — set flag and return
                     Thread.currentThread().interrupt();
                     return;
                }
            }
            if (toRun.getProcessingTime() <= toRun.getTotalTimeSpent()) {
                toRun.getPcb().setStatus("terminated");
                // Wake up the thread if it's waiting so it can finish
                try {
                    synchronized (toRun) {
                        toRun.notify();
                    }
                } catch (IllegalMonitorStateException ignored) {}
                try {
                    toRun.interrupt();
                } catch (SecurityException ignored) {}

                terminatedProcessList.add(toRun);
                // Ensure no lingering references in ready queue
                readyQueue.removeValue(toRun.getPcb());
            } else {
                readyQueue.enqueue(toRun.getPcb());
            }
        }
    }
    
    
    public void SPN(Cola readyQueue, Dispatcher dispatcher, Cola blockedQueue, Lista terminatedProcessList){
        if (readyQueue.getCount() > 0){
            var processToActivate = readyQueue.get(0);
            PCB pcbOfActiveProcess = ((PCB)processToActivate);
            
            // verificar si el proceso ya está activado y si no lo está, activarlo
            if (pcbOfActiveProcess.getStatus() != "running"){ //
                dispatcher.activate(pcbOfActiveProcess, getProcessList()); // ready ---> running
            }
            
            // while running
            Proceso toRun = dispatcher.getActiveProcess(processList);
            
            while(toRun.getPcb().getStatus() == "running"){
                if (Thread.currentThread().isInterrupted()) return;

                if (toRun.getProcessingTime() == toRun.getTimeSpent()){
                    dispatcher.deactivate(toRun);
                    readyQueue.dequeue();
                }
                if (toRun.getBound() == "I/O Bound" && toRun.getPcb().getPc()-1 == toRun.getInterruptAt()){
                    toRun.getPcb().setStatus("blocked");
                    blockedQueue.enqueue(toRun.getPcb());
                    try {
                        toRun.sleep(toRun.getIoCicles()*1000);
                        accessDevice(toRun, dispatcher, blockedQueue);
                    } 
                    catch(InterruptedException e) {
                         Thread.currentThread().interrupt();
                         return;
                    }
                }
                try {
                    Thread.sleep(1000);
                } 
                catch(InterruptedException e) {
                     Thread.currentThread().interrupt();
                     return;
                }
                }
            if (toRun.getProcessingTime() <= toRun.getTotalTimeSpent()) {
                toRun.getPcb().setStatus("terminated");
                terminatedProcessList.add(toRun);
            } else {
                readyQueue.enqueue(toRun.getPcb());
            }
            }
        }
    
    
    public void PriorityPlanification(int quantum, Cola readyQueue, Dispatcher dispatcher, Lista priorityList, Cola blockedQueue, Lista terminatedProcessList){
        for (int i = 0; i < priorityList.count(); i++){
            // check interruption on top of loops
            if (Thread.currentThread().isInterrupted()) return;

            Cola act = (Cola)priorityList.get(i);
            
            PCB pcbOfActiveProcess = (PCB) act.dequeue();
            
            
            if (act.getCount() > 0){
                readyQueue.getQueue().remove(readyQueue.getQueue().indexOf(pcbOfActiveProcess));
                if (pcbOfActiveProcess.getStatus() != "running"){
                    dispatcher.activate(pcbOfActiveProcess, processList);
                }
                
                //while running
                Proceso toRun = dispatcher.getActiveProcess(processList);
                while(toRun.getPcb().getStatus() == "running") {
                    if (Thread.currentThread().isInterrupted()) return;

                    if (toRun.getTimeSpent() >= quantum || toRun.getProcessingTime() <= toRun.getTotalTimeSpent()){
                        dispatcher.deactivate(toRun);   // running --> ready                    
                    }
                    if (toRun.getBound() == "I/O Bound" && toRun.getPcb().getPc()-1 == toRun.getInterruptAt()){
                        toRun.getPcb().setStatus("blocked");
                        blockedQueue.enqueue(toRun.getPcb());
                        try {
                            toRun.sleep(toRun.getIoCicles()*1000);
                            accessDevice(toRun, dispatcher, blockedQueue);
                        } 
                        catch(InterruptedException e) {
                             Thread.currentThread().interrupt();
                             return;
                        }                
                    }                

                    try {
                        Thread.sleep(1000);
                    } 
                    catch(InterruptedException e) {
                         Thread.currentThread().interrupt();
                         return;
                    }
                }
                if (toRun.getProcessingTime() <= toRun.getTotalTimeSpent()) {
                    toRun.getPcb().setStatus("terminated");
                    terminatedProcessList.add(toRun);
                } else {
                    act.enqueue(toRun.getPcb());
                    readyQueue.enqueue(toRun.getPcb());
                }
                }
            }
        }
    
    
    public void Feedback(int setQuantum, Cola readyQueue, Lista readyQueueList, Dispatcher dispatcher, Cola blockedQueue, Lista terminatedProcessList) {
        System.out.println("en feedback");
        int quantum = setQuantum;
        int i = 0;
        if (Thread.currentThread().isInterrupted()) return;
        PCB processToActivate = null;

        // Defensive iteration over readyQueueList: check for nulls and types
        while (i < readyQueueList.count()) {
            if (Thread.currentThread().isInterrupted()) return;

            Object bucketObj = readyQueueList.get(i);
            if (bucketObj == null) {
                i++;
                continue;
            }
            if (!(bucketObj instanceof Cola)) {
                i++;
                continue;
            }

            Cola bucket = (Cola) bucketObj;
            if (bucket.getCount() > 0) {
                System.out.println("activando");
                Object dequeued = bucket.dequeue();
                if (dequeued == null) {
                    i++;
                    continue;
                }
                if (!(dequeued instanceof PCB)) {
                    // normalize: suport Proceso stored inside by mistake
                    if (dequeued instanceof Proceso) {
                        dequeued = ((Proceso) dequeued).getPcb();
                        if (dequeued == null) {
                            i++;
                            continue;
                        }
                    } else {
                        i++;
                        continue;
                    }
                }
                processToActivate = (PCB) dequeued;
                System.out.println("id del proceso" + processToActivate.getId());
                dispatcher.activate(processToActivate, processList);
                System.out.println("status del pta" + processToActivate.getStatus());

                // remove any lingering reference from the global readyQueue
                readyQueue.removeValue(processToActivate);

                break;
            }
            i++;
        }

        Proceso toRun = dispatcher.getActiveProcess(processList);
        if (toRun == null) return;
        if (Thread.currentThread().isInterrupted()) return;

        toRun.getPcb().setTimesIn(toRun.getPcb().getTimesIn()+1);
        while ("running".equals(toRun.getPcb().getStatus())) {
            if (Thread.currentThread().isInterrupted()) return;

            if (toRun.getTimeSpent() >= quantum || toRun.getProcessingTime() <= toRun.getTotalTimeSpent()){
                dispatcher.deactivate(toRun);   // running --> ready
            }
            if ("I/O Bound".equals(toRun.getBound()) && toRun.getPcb().getPc()-1 == toRun.getInterruptAt()){
                toRun.getPcb().setStatus("blocked");
                System.out.println("bloqueado");
                blockedQueue.enqueue(toRun.getPcb());
                try {
                    toRun.sleep(toRun.getIoCicles()*1000);

                    accessDevice(toRun, dispatcher, blockedQueue);
                } 
                catch(InterruptedException e) {
                     Thread.currentThread().interrupt();
                     return;
                }

            }
             try {
                Thread.sleep(1000);
            } 
            catch(InterruptedException e) {
                 Thread.currentThread().interrupt();
                 return;
            }

        }
        if (toRun.getProcessingTime() <= toRun.getTotalTimeSpent()) {
            toRun.getPcb().setStatus("terminated");
            terminatedProcessList.add(toRun);
        } else {
            if (toRun.getPcb().getTimesIn() < readyQueueList.count()) {
                Object obj = readyQueueList.get(toRun.getPcb().getTimesIn());
                if (obj instanceof Cola) {
                    ((Cola) obj).enqueue(toRun.getPcb());
                    readyQueue.enqueue(toRun.getPcb());
                } else {
                    // create bucket if missing
                    Cola aux = new Cola();
                    readyQueueList.add(aux);
                    aux.enqueue(toRun.getPcb());
                    readyQueue.enqueue(toRun.getPcb());
                }
            } else {
                Cola aux = new Cola();
                readyQueueList.add(aux);
                ((Cola) readyQueueList.get(toRun.getPcb().getTimesIn())).enqueue(toRun.getPcb());
                readyQueue.enqueue(toRun.getPcb());
            }
        }
    }

    public void FSS(int setQuantum, Cola readyQueue, Dispatcher dispatcher, Cola blockedQueue, Lista terminatedProcessList) {
        int quantum = setQuantum;
        if (readyQueue.getCount() > 0) {
            
            var processToActivate = readyQueue.dequeue();
            dispatcher.activate(((PCB)(processToActivate)), getProcessList());
            
            Proceso toRun = dispatcher.getActiveProcess(getProcessList());
            if (toRun == null) return;

            while (toRun.getPcb().getStatus() == "running"){
                if (Thread.currentThread().isInterrupted()) return;

                if (toRun.getTimeSpent() >= quantum || toRun.getProcessingTime() <= toRun.getTotalTimeSpent()){
                    dispatcher.deactivate(toRun);   // running --> ready
                }
                if (toRun.getBound() == "I/O Bound" && toRun.getPcb().getPc()-1 == toRun.getInterruptAt()){
                    toRun.getPcb().setStatus("blocked");
                    blockedQueue.enqueue(toRun.getPcb());
                    try {
                        toRun.sleep(toRun.getIoCicles()*1000);
                        accessDevice(toRun, dispatcher, blockedQueue);
                    } 
                    catch(InterruptedException e) {
                         Thread.currentThread().interrupt();
                         return;
                    }                
                }                
                try {
                    Thread.sleep(1000);
                } 
                catch(InterruptedException e) {
                     Thread.currentThread().interrupt();
                     return;
                }
            }
            if (toRun.getProcessingTime() <= toRun.getTotalTimeSpent()) {
                toRun.getPcb().setStatus("terminated");
                terminatedProcessList.add(toRun);
            } else {
                readyQueue.enqueue(toRun.getPcb());
            }
        }
    }
    
    public void SRT (Cola readyQueue, Dispatcher dispatcher, Cola blockedQueue, Lista terminatedProcessList) {
        if (readyQueue.getCount() > 0) {
            var processToActivate = readyQueue.dequeue();
            dispatcher.activate(((PCB)(processToActivate)), getProcessList());
            
            Proceso toRun = dispatcher.getActiveProcess(getProcessList());
            if (toRun == null) return;

            while (toRun.getPcb().getStatus() == "running"){
                if (Thread.currentThread().isInterrupted()) return;

                if (toRun.getProcessingTime() <= toRun.getTimeSpent()){
                    dispatcher.deactivate(toRun);
                    readyQueue.dequeue();
                }
                if (toRun.getBound() == "I/O Bound" && toRun.getPcb().getPc()-1 == toRun.getInterruptAt()){
                    toRun.getPcb().setStatus("blocked");
                    blockedQueue.enqueue(toRun.getPcb());
                    try {
                        toRun.sleep(toRun.getIoCicles()*1000);
                        accessDevice(toRun, dispatcher, blockedQueue);
                    } 
                    catch(InterruptedException e) {
                         Thread.currentThread().interrupt();
                         return;
                    }
                }
                try {
                    Thread.sleep(1000);
                } 
                catch(InterruptedException e) {
                     Thread.currentThread().interrupt();
                     return;
                }
            }
            if (toRun.getProcessingTime() <= toRun.getTotalTimeSpent()) {
                toRun.getPcb().setStatus("terminated");
                terminatedProcessList.add(toRun);
            } else {
                readyQueue.enqueue(toRun.getPcb());
            }
        }
    }
    
    //La lista de prioridades es una lista que contiene las prioridades
    public Lista reorganicePriorityPlanification(Cola readyQueue, Lista priorityList){
        
        // Creando la cantidad de colas necesarias segun las prioridades existentes
        if (priorityList.count() < 1){
            int maxpriority = getPriorities(readyQueue);
            
            for (int i = 0; i < maxpriority; i++){
                Cola aux = new Cola();
                priorityList.add(aux);
            }
        } 
        
        // Agregar cada proceso a su lista de prioridad correspondiente
        for (int j=0; j < readyQueue.getCount(); j++){
            PCB aux = (PCB)readyQueue.get(j);
            
            for (int x=0; x < priorityList.count(); x++){
                Cola act = (Cola)priorityList.get(x);
                
                if(aux.getPriority() == x & !act.getQueue().contains(aux)){
                    act.enqueue(aux);
                }
            }
        }
    
        return priorityList;
    }
    
    public void reorganiceSPN(Cola readyQueue){
        if (readyQueue == null) return;
        if (readyQueue.getQueue() == null) return;
        if (readyQueue.getCount() < 2) return;
        
        synchronized (readyQueue.getQueue()) {
            for (int pass = 0; pass < readyQueue.getCount() - 1; pass++) {
                boolean swapped = false;
                for (int i = 0; i < readyQueue.getCount() - 1 - pass; i++) {
                    Object o1 = readyQueue.getQueue().get(i);
                    Object o2 = readyQueue.getQueue().get(i + 1);

                    if (!(o1 instanceof PCB) || !(o2 instanceof PCB)) {
                        continue;
                    }

                    PCB pcb1 = (PCB) o1;
                    PCB pcb2 = (PCB) o2;
                    Proceso p1 = findProcessByPCB(pcb1);
                    Proceso p2 = findProcessByPCB(pcb2);

                    // If either Proceso is missing, skip this pair
                    if (p1 == null || p2 == null) continue;

                    // Compare processing time and swap underlying list if out of order
                    if (p1.getProcessingTime() > p2.getProcessingTime()) {
                        readyQueue.getQueue().swap(i, i + 1);
                        swapped = true;
                    }
                }
                if (!swapped) break; // already sorted
            }
        }
    }
    
    
    public void reorganiceFeedback (Cola readyQueue, Lista readyQueueList) {

        if (readyQueueList.count() < getTimesIn(readyQueue)){
            int maxTimesIn = getTimesIn(readyQueue);
            
            int i = readyQueueList.count();
            
            while (i < maxTimesIn) {
                Cola aux = new Cola();
                readyQueueList.add(aux);
                i++;
            }
        }
        int i = 0;
        while (i < readyQueue.getCount()) {
            int j = 0;
            int index = ((PCB)readyQueue.get(i)).getTimesIn();
            while (j < readyQueueList.count()){
                if ( index == j && !(((Cola)readyQueueList.get(j)).getContains(readyQueue.get(i)))) {
                    ((Cola)readyQueueList.get(j)).enqueue(readyQueue.get(i));
                }
                j++;
            }
            i++;
        }
    }
    
    public void reorganiceFSS (Cola readyQueue){
        int i = 0;
        int n = readyQueue.getCount();
        while (i < n){
            PCB aux = (PCB)readyQueue.get(i);
            int j = i + 1;
            
            while (j < n){
                PCB aux2 = (PCB)readyQueue.get(j);
                if (aux.getPriorityFSS()>aux2.getPriorityFSS()){
                    readyQueue.getQueue().swap(i, j);
                }
                j++;
            }
            i++;
        }
    }
    
    public void recalculateFSS (Cola readyQueue, int priority) {
        int i = 0;
        int n = readyQueue.getCount();
        int timesInTotal = 0;
        int priorityCount = 0;
        while (i < n) {
            if (((PCB)readyQueue.get(i)).getPriority() == priority) {
                timesInTotal = ((PCB)readyQueue.get(i)).getTimesIn() + timesInTotal;
                priorityCount++;
            }
            i++;
        }
        i = 0;
        while (i < n) {
            if (((PCB)readyQueue.get(i)).getPriority() == priority) {
                int priorityNode = ((PCB)readyQueue.get(i)).getPriority();
                int timesIn = ((PCB)readyQueue.get(i)).getTimesIn();
                
                float newPriorityFSS = priorityNode + timesIn + (timesInTotal/priorityCount);
                
                ((PCB)readyQueue.get(i)).setPriorityFSS(newPriorityFSS);
            }
            i++;
        }
    }
    
    
    public void reorganiceSRT (Cola readyQueue){
        int i = 0;
        int n = readyQueue.getCount();
        while (i < n){
            
            PCB aux = (PCB) readyQueue.get(i);

            int j = i + 1;
            
            while (j < n){
                PCB aux2 = (PCB)readyQueue.get(j);
                if (aux.getPriorityFSS() > aux2.getPriorityFSS()){

                    readyQueue.getQueue().swap(i, j);

                }
                j++;
            }
            i++;
        }
    }
    
    
    public int getPriorities(Cola readyQueue){
        Lista priorities = new Lista();
        
        for (int i = 0; i < readyQueue.getCount(); i++){
            PCB aux = (PCB)readyQueue.get(i);
            if (!priorities.contains(aux.getPriority())){
                priorities.add(aux.getPriority());
            }
        }
        
        return priorities.count();
    }

    public int getTimesIn(Cola readyQueue){
        Lista timesIn = new Lista();
        
        for (int i = 0; i < readyQueue.getCount(); i++){
            var aux = (PCB)readyQueue.get(i);
            
            if (!timesIn.contains(aux.getTimesIn())){
                timesIn.add(aux.getTimesIn());
            }
        }
        return timesIn.count();
    }
    
    /**
     * @return the processList
     */
    public Lista getProcessList() {
        return processList;
    }

    /**
     * @param processList the processList to set
     */
    public void setProcessList(Lista processList) {
        this.processList = processList;
    }

    /**
     * @return the memoryAvaiable
     */
    public int getMemoryAvaiable() {
        return memoryAvaiable;
    }

    /**
     * @param memoryAvaiable the memoryAvaiable to set
     */
    public void setMemoryAvaiable(int memoryAvaiable) {
        this.memoryAvaiable = memoryAvaiable;
    }

    /**
     * @return the remainingSpace
     */
    public int getRemainingSpace() {
        return remainingSpace;
    }

    /**
     * @param remainingSpace the remainingSpace to set
     */
    public void setRemainingSpace(int remainingSpace) {
        this.remainingSpace = remainingSpace;
    }
    
    
    public void accessDevice(Proceso blockedProcess, Dispatcher dispatcher, Cola blockedQueue){
        int i = 0;
        while (i < deviceTable.count()){
            if (Thread.currentThread().isInterrupted()) return;
            if (blockedProcess.getDeviceToUse() == ((Device)deviceTable.get(i)).getId()){
                try {
                    System.out.println("accediendo al device");
                    ((Device)deviceTable.get(i)).getSemaf().acquire();
                } catch(InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
                break;
            }
            i++;
        }
        try {
            blockedProcess.sleep(blockedProcess.getSatisfyCicles()*1000);
            ((Device)deviceTable.get(i)).getSemaf().release();
            dispatcher.deactivate(blockedProcess);
            blockedQueue.getQueue().remove(blockedQueue.getQueue().indexOf(blockedProcess.getPcb()));
        } 
        catch(InterruptedException e) {
             Thread.currentThread().interrupt();
             return;
        }
    }
    
     public Proceso findProcessByPCB(PCB pcb) {
        if (pcb == null) return null;

        int n = (processList == null) ? 0 : processList.count();
        for (int i = 0; i < n; i++) {
            Object o = processList.get(i);
            if (o instanceof Proceso) {
                Proceso p = (Proceso) o;
                PCB ppcb = p.getPcb();
                if (ppcb != null && ppcb.getId() == pcb.getId()) {
                    return p;
                }
            }
        }
        return null;
    }
    
}```

What to do next
- Apply these two file replacements in your repo and run the scenario that previously raised the NPE (the Feedback scheduling flow). The NPE coming from Lista.get should be gone.
- If you still see unexpected nulls, I can run a quick search for all places that call Lista.get without checking for null and add defensive checks or fix caller logic (e.g., replace getQueue().indexOf(...) usage with Cola helpers).

If you want, I can commit these changes directly to a branch and open a PR for you — tell me whether to push to a new branch (e.g., fix/defensive-lista-feedback) and whether to include any additional changes (like converting other recursive methods to iterative).
